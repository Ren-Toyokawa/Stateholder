# StateHolder KMP

[![Kotlin](https://img.shields.io/badge/kotlin-2.0.10-blue.svg?logo=kotlin)](http://kotlinlang.org)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

A Kotlin Multiplatform library for state management with KSP code generation. StateHolder provides a clean architecture pattern for separating UI state management from ViewModels, enabling better testability and reusability.

## üéØ Key Concepts

### StateHolder
Encapsulates state management and business logic for specific UI features. Separates concerns from ViewModels, improving testability and reusability.

### SharedState  
States shared between multiple StateHolders within ViewModel scope. Automatically managed following ViewModel lifecycle, ensuring state consistency.

### Type-Safe Dependency Injection
Automatic StateHolder resolution through type inference. KSP-generated parameter mapping automatically connects SharedStates.

## üì¶ Installation

The library will be available on Maven Central (coming soon). For now, you can use it as a local dependency.

### Gradle Setup

```kotlin
dependencies {
    implementation("io.github.rentoyokawa:stateholder-annotations:0.1.0")
    implementation("io.github.rentoyokawa:stateholder-core:0.1.0")
    implementation("io.github.rentoyokawa:stateholder-viewmodel:0.1.0")
    ksp("io.github.rentoyokawa:stateholder-ksp:0.1.0")
    
    // Optional: Koin integration
    implementation("io.github.rentoyokawa:stateholder-koin:0.1.0")
}
```

## üöÄ Quick Start

### 1. Define SharedState

```kotlin
// State shared in ViewModel scope
class UserSharedState {
    var userId: String = ""
    var userName: String = ""
}

class ProductSharedState {
    var productId: String = ""
    var productName: String = ""
    var price: Int = 0
}
```

### 2. Implement StateHolder

```kotlin
@StateHolder
class UserStateHolder(
    @InjectedParam private val userState: UserSharedState,
    private val userRepository: UserRepository,
    scope: CoroutineScope
) : StateHolder<UserSource, UserUiState, UserAction>(scope) {
    
    // Internal state definition
    data class UserSource(
        val user: User?,
        val isLoading: Boolean
    )
    
    // UI state definition
    data class UserUiState(
        val displayName: String,
        val isLoggedIn: Boolean,
        val isLoading: Boolean
    )
    
    // User actions
    interface UserAction {
        fun login(userId: String, name: String)
        fun logout()
    }
    
    override fun defineState(source: UserSource): UserUiState {
        return UserUiState(
            displayName = source.user?.name ?: "",
            isLoggedIn = source.user != null,
            isLoading = source.isLoading
        )
    }
    
    override val action = object : UserAction {
        override fun login(userId: String, name: String) {
            userState.userId = userId
            userState.userName = name
            // Repository calls, etc.
        }
        
        override fun logout() {
            userState.userId = ""
            userState.userName = ""
        }
    }
}
```

### 3. Use in ViewModel

```kotlin
class MainViewModel : ViewModel() {
    // Declare SharedStates
    @SharedState
    internal val userState = UserSharedState()
    
    @SharedState
    internal val productState = ProductSharedState()
    
    // Inject StateHolders (auto-resolved by type inference)
    val userStateHolder: UserStateHolder by stateHolder()
    val productStateHolder: ProductStateHolder by stateHolder()
    
    // Combine states at ViewModel level
    val canPurchase: StateFlow<Boolean> = combine(
        userStateHolder.state,
        productStateHolder.state
    ) { userState, productState ->
        userState.isLoggedIn && productState.price > 0
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(), false)
}
```

## üèóÔ∏è Architecture

### Data Flow

```
UI Layer
    ‚Üì observe
ViewModel (manages SharedState)
    ‚Üì delegate
StateHolder (business logic)
    ‚Üì call
Repository/UseCase
    ‚Üì fetch
DataSource (API/DB)
```

### Communication via SharedState

```kotlin
// StateHolder A updates SharedState
productStateHolder.action.selectProduct(productId)
    ‚Üì
// SharedState is updated
ProductSharedState.selectedProductId = productId
    ‚Üì
// StateHolder B automatically reacts
cartStateHolder // Updates cart with selected product
detailStateHolder // Loads product details
```

## üõ†Ô∏è KSP Code Generation

The library uses KSP to generate boilerplate code for dependency injection and parameter mapping.

### Generated Parameter Provider

```kotlin
// Auto-generated by KSP
internal fun MainViewModel.getStateHolderParametersForType(
    stateHolderType: KClass<*>
): List<Any> = when (stateHolderType) {
    UserStateHolder::class -> listOf(this.userState)
    ProductStateHolder::class -> listOf(this.productState)
    else -> emptyList()
}
```

### Generated Koin Module

```kotlin
// Auto-generated by KSP
val stateHolderModule = module {
    factory<UserStateHolder> { params ->
        UserStateHolder(
            userState = params.get(),
            userRepository = get(),
            scope = params.get()
        )
    }
}
```

## ‚ú® Features

- **Type Safety**: Compile-time type checking with explicit dependencies
- **Separation of Concerns**: Clear responsibility boundaries between components
- **Testability**: Independent testing of each component
- **Performance**: Efficient updates with StateFlow and lazy initialization
- **Multiplatform**: Support for Android, iOS, and JVM targets

## üì± Platform Support

- Android (minSdk 24)
- iOS (iosX64, iosArm64, iosSimulatorArm64)
- JVM

## üìù Best Practices

### 1. Single Responsibility Principle
```kotlin
// Good: Focused on single feature
class UserProfileStateHolder : StateHolder<UserSource, UserState, UserAction>

// Bad: Mixed responsibilities
class UserAndProductStateHolder : StateHolder<MixedSource, MixedState, MixedAction>
```

### 2. Normalized SharedState
```kotlin
// Good: Normalized data
class UserSharedState {
    var userId: String = ""
    // ID reference only
}

// Bad: Duplicate data
class UserSharedState {
    var user: User? = null
    var userProfile: Profile? = null
}
```

### 3. Pure Functions
```kotlin
// Good: No side effects
override fun defineState(source: UserSource): UserState {
    return UserState(name = source.user?.name ?: "")
}

// Bad: With side effects
override fun defineState(source: UserSource): UserState {
    analytics.track("state_defined") // Side effect!
    return UserState(name = source.user?.name ?: "")
}
```

## üîÑ Roadmap

- **v0.2.0**: Enhanced error handling and state recovery
- **v0.3.0**: Debug tools and state inspection
- **v0.4.0**: Performance optimizations
- **v1.0.0**: Stable API with full documentation

## üìö Documentation

- [Architecture Overview](./ARCHITECTURE.md)
- [API Documentation](https://github.com/Ren-Toyokawa/stateholder-kmp/wiki) (coming soon)
- [Migration Guide](https://github.com/Ren-Toyokawa/stateholder-kmp/wiki/Migration-Guide) (coming soon)

## ü§ù Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## üìÑ License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.

## üë®‚Äçüíª Author

**Ren Toyokawa**
- GitHub: [@Ren-Toyokawa](https://github.com/Ren-Toyokawa)

## üôè Acknowledgments

- Inspired by modern Android architecture patterns
- Built with Kotlin Multiplatform
- Code generation powered by KSP